:import "io"
:import "net"
:import "os/error"

:actor Main
  :new (env)
    PostgresConnection.new(env, "127.0.0.1", "username", "database")

:primitive MessageEncoder
  :fun startup_message(user String'val, database String'val, protocol_version = U32[3].bit_shl(16)) Bytes'iso
    msg = Bytes.new_iso
    msg.push_native_u32(0) // message length placeholder
    msg.push_native_u32(protocol_version.native_to_be)
    msg << b"user"
    msg.push(0)
    msg << user.as_bytes
    msg.push(0)
    msg << b"database"
    msg.push(0)
    msg << database.as_bytes
    msg.push(0)
    msg.push(0)
    try msg.write_native_u32!(0, msg.size.u32.native_to_be)
    --msg

  :fun query_message(query String'val) Bytes'iso
    msg = Bytes.new_iso
    msg.push('Q')
    msg.push_native_u32(0) // message length placeholder
    msg << query.as_bytes
    msg.push(0)
    try msg.write_native_u32!(1, (msg.size - 1).u32.native_to_be)
    --msg


:actor PostgresConnection
  :is IOActor(IOAction)
  :let env Env
  :let io TCPConnectionEngine
  :let user String
  :let database String

  :new (@env, host String, @user, @database)
    @io = TCPConnectionEngine.connect(@, host, "5432")

    if (@io.connect_error != OSErrorNone) (
      @env.err.print("[PostgresConnection] Failed to connect:")
      @env.err.print(@io.connect_error.name)
    )
  
  :fun ref _io_react(action IOAction)
    case action == (
    | IOActionOpened |
      @env.err.print("[PostgresConnection] Connected")
      @io.write_stream << --MessageEncoder.startup_message(@user, @database)
      @io.flush

    | IOActionOpenFailed |
      @env.err.print("[PostgresConnection] Failed to connect:")
      @env.err.print(@io.connect_error.name)

    | IOActionWrite |
      @io.flush

    | IOActionRead |
      @io.pending_reads -> (bytes_available |
        try (
          while (@_process_message!) ()
        |
          @env.err.print("FAILED")
          @io.close
        )
      )

    | IOActionClosed |
      @env.err.print("[PostgresConnection] Closed")
      try @io.listen.as!(TCPListener).dispose
    )
    @

  :: Processes a message at the current cursor position.
  ::
  :: Returns False if it needs more data to process the next message.
  :fun ref _process_message! Bool
    // expect cursor and mark position to be the same 
    if (@io.read_stream.token_byte_size > 0) (error!)

    // XXX: We don't need this
    // Ensure that cursor and mark position are the same
    @io.read_stream.mark_here

    if (@io.read_stream.bytes_ahead < 5) (
      // Not enough bytes in buffer
      return False
    )

    @io.read_stream.advance!(5)
    message_type = @io.read_stream.read_byte!(0)
    message_length = @io.read_stream.read_be_u32!(1)

    if (message_length < 4) (
      @env.err.print("Invalid message length")
      error!
    )

    body_length = message_length.usize - 4

    if (@io.read_stream.bytes_ahead < body_length) (
      @env.err.print("Not enough bytes ahead")
      @io.read_stream.rewind_to_marker
      return False
    )

    @io.read_stream.mark_here
    @io.read_stream.advance!(body_length)

    case message_type == (
    | 'E' | @env.err.print(">ErrorResponse")
    | 'N' | @env.err.print(">NoticeResponse")
    | 'G' | @env.err.print(">CopyInResponse")
    | 'H' | @env.err.print(">CopyOutResponse")
    | 'P' | @env.err.print(">Parse")
    | '1' | @env.err.print(">ParseComplete")
    | 'R' | @env.err.print(">Authentification")
    | 'S' | @env.err.print(">ParameterStatus")
    | 'Z' |
      @env.err.print(">ReadyForQuery")
      @io.write_stream << --MessageEncoder.query_message("select now(), random()")
      @io.flush
    | 'I' |
      @env.err.print(">EmptyQueryResponse")
    | 'D' |
      @env.err.print(">DataRow")
      n_cols = @_next_be_u16!
      while (n_cols > 0) (
        len = @_next_be_u32!
        if (len == 0xFFFF_FFFF) (
          @env.err.print("NULL")
        |
          bytes = @_next_bytes!(len.usize)
          @env.err.print(Inspect[(--bytes).as_string])
        )
        n_cols -= 1
      )
      if (@io.read_stream.token_byte_size > 0) (
        error!
      )

    | 'T' |
      @env.err.print(">RowDescription")
      n_fields = @_next_be_u16!
      while (n_fields > 0) (
        field_name = @_next_cstring!
        field_oid = @_next_be_u32!.i32
        field_attr_nr = @_next_be_u16!.i16
        field_type_oid = @_next_be_u32!.i32
        field_typlen = @_next_be_u16!.i16
        field_atttypmod = @_next_be_u32!.i32
        field_formatcode = @_next_be_u16!.i16

        @env.err.print(field_name)

        n_fields -= 1
      )
      if (@io.read_stream.token_byte_size > 0) (
        error!
      )

    | 'C' | @env.err.print(">CommandComplete")
    | 'K' | @env.err.print(">BackendKeyData")
    | 'X' |
      @env.err.print(">Terminate")
      @io.close
    |
      @env.err.print("-------------------------------")
      @env.err.print("Unknown message")
      @env.err.print("-------------------------------")
      bytes = @_next_bytes!(body_length)
      @env.err.print(Inspect[(--bytes).as_string])
      @io.close
    )

    // 
    @io.read_stream.mark_here
    True

  :fun ref _next_byte! U8
      value = @io.read_stream.read_byte!(0)
      @io.read_stream.advance_mark!(1)
      value

  :fun ref _next_be_u16! U16
      value = @io.read_stream.read_be_u16!(0)
      @io.read_stream.advance_mark!(2)
      value

  :fun ref _next_be_u32! U32
      value = @io.read_stream.read_be_u32!(0)
      @io.read_stream.advance_mark!(4)
      value

  :fun ref _next_bytes!(n USize) Bytes'iso
      bytes = @io.read_stream.read_bytes!(0, n)
      @io.read_stream.advance_mark!(n)
      --bytes

  :fun ref _next_cstring! String
      bytes = Bytes.new_iso
      while (True) (
        byte = @_next_byte!
        break if (byte == 0)
        bytes.push(byte)
      )
      String.from_bytes(--bytes)


