:: This class provides a way to buffer writes to a data sink, in the form of
:: chunks that arrive one at a time, then get flushed all together to the sink.
::
:: This batched writing pattern amortizes the cost of writing to the sink.
:: but its up to the caller to determine when to flush, based on whatever
:: performance tuning and/or heuristics deemed appropriate for the application.
:class ByteStream.ChunkedWriter
  :is ByteStream.Writable

  :let _chunks Array(Bytes.Slice): []
  :var _total_size USize: 0
  :var _windows_unacknowledged_chunks USize: 0
  :var _windows_unacknowledged_total_size USize: 0

  :: Add a chunk of bytes to the stream.
  ::
  :: It won't actually get written until the flush method is called.
  :fun ref "<<"(chunk Bytes'val)
    @_chunks << chunk.as_slice
    @_total_size += chunk.size
    @

  :: Try to write all buffered data to the given target.
  ::
  :: If all data was successfully flushed into the target, it returns True.
  :: Otherwise, some data was not written and this must be called again later.
  ::
  :: If the given target is not in a writable state when calling this method,
  :: then no data will be written and it was useless to make this call.
  :fun ref flush(target ByteStream.ChunkedSink) Bool
    case (
    | @_total_size == 0      | True  // nothing left to flush
    | target.is_writable.not | False // can't flush right now
    | Platform.windows       | @_flush_windows(target)
    |                          @_flush_posix(target)
    )

  :fun ref _flush_posix(target ByteStream.ChunkedSink) Bool
    writev_max_chunks = target.writev_posix_max_chunks
    num_to_send USize = 0
    bytes_to_send USize = 0

    try (
      while (@_total_size > 0) (
        if (@_chunks.size < writev_max_chunks) (
          num_to_send = @_chunks.size
          bytes_to_send = @_total_size
        |
          num_to_send = writev_max_chunks
          // TODO: This could be done with an equivalent reduce
          bytes_to_send = 0
          @_chunks.each(0, num_to_send) -> (chunk |
            bytes_to_send += chunk.size
          )
        )

        bytes_written = target.writev_posix!(@_chunks, num_to_send)
        @_manage_chunks(bytes_written, bytes_to_send, num_to_send)
      )
      True
    |
      False
    )

  :fun ref _flush_windows(target ByteStream.ChunkedSink) Bool
    try (
      target.writev_windows!(@_chunks, @_windows_unacknowledged_chunks)
      @_windows_unacknowledged_chunks += @_chunks.size
      @_windows_unacknowledged_total_size = @_total_size
      True
    |
      False
    )

  :fun ref acknowledge_writes_windows(bytes_written USize)
    @_manage_chunks(
      bytes_written
      @_windows_unacknowledged_total_size
      @_windows_unacknowledged_chunks
    )
    @

  :fun ref _manage_chunks(
    bytes_sent USize
    bytes_to_send USize
    num_to_send USize
  )
    @_total_size -= bytes_sent
    if (bytes_sent == bytes_to_send) (
      // Fast path for the case of having sent all bytes we wanted to send.
      // We can simply trim the intended number of chunks.
      @_chunks.trim_in_place(num_to_send)
    |
      // Otherwise, we need to iterate through the pending writev chunks,
      // Clearing away those that are already sent, but keeping the rest.

      // Find the index of the first chunk size pointer that was not fully sent,
      // and also get a count of how many bytes worth of size were sent in it.
      further_bytes_sent = bytes_sent
      lingering_chunk_index = try (
        @_chunks.find_index! -> (chunk |
          try (
            further_bytes_sent = further_bytes_sent -! chunk.size
            False
          |
            True
          )
        )
      |
        // We don't expect this to ever be reached, because that would imply
        // that all of the bytes in _data_pairs were already sent.
        // But if that were true, we wouldn't even have taken this slow path
        // of counting bytes in chunks - we would have used the fast path.
        // So in the error case of this being reached, we still behave correctly
        // by just using an index beyond the end of the array size,
        // which will cause us to trim away everything in the array.
        further_bytes_sent = 0
        @_chunks.size
      )

      // If the lingering chunk was only partially sent, we need to trim it.
      if (further_bytes_sent > 0) (
        try (
          @_chunks.replace_at!(lingering_chunk_index) -> (chunk |
            chunk.trim(further_bytes_sent)
          )
        )
      )

      // Trim the left side of the array to remove the fully sent bytes.
      @_chunks.trim_in_place(lingering_chunk_index)
    )
    @

