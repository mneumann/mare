:trait box _InspectEach
  // TODO: use each instead of size and []!
  :fun size USize
  :fun "[]!"(index USize) Any'box // TODO: use `box` instead of `Any'box`

:trait box _InspectCustom
  :fun inspect_into(output String'iso) String'iso

// TODO: Move this out of savi maybe? Does that make sense?
// TODO: Make this into a trait with "implement for"/typeclass style polymorphism
:module Inspect
  :fun "[]"(input Any'box) String'val // TODO: use `box` instead of `Any'box`
    @into(String.new_iso, input)

  :fun out(input Any'box) // TODO: use `box` instead of `Any'box`
    _FFI.puts(@[input].cstring)

  :fun into(output String'iso, input Any'box) String'iso // TODO: use `box` instead of `Any'box` // TODO: use something like Crystal IO instead of String?
    case input <: (
    | _InspectCustom | input.inspect_into(--output)
    | String'box |
      output.push_byte('"')
      output << input.clone // TODO: show some characters as escaped.
      output.push_byte('"')
      --output
    | Bytes'box |
      output.push_byte('b')
      output.push_byte('"')
      input.each -> (byte |
        case (
        | byte >= 0x7F | output = @_inspect_hex_byte_escape_into(--output, byte)
        | byte == '"'  | output.push_byte('\\').push_byte('"')
        | byte >= 0x20 | output.push_byte(byte)
        | byte == '\n' | output.push_byte('\\').push_byte('n')
        | byte == '\r' | output.push_byte('\\').push_byte('r')
        | byte == '\t' | output.push_byte('\\').push_byte('t')
        |                output = @_inspect_hex_byte_escape_into(--output, byte)
        )
      )
      output.push_byte('"')
      --output
    | _InspectEach |
      output.push_byte('[')
      index USize = 0
      while (index < input.size) (
        if (index > 0) (output.push_byte(','), output.push_byte(' '))
        try (
          element = input[index]!
          output = @into(--output, element)
        )
        index += 1
      )
      output.push_byte(']')
      --output
    | IntoString |
      // If there's nothing more specific, then our last option is to print
      // the same representation that `into_string` gives for that value.
      input.into_string(--output)
    |
      // Otherwise, fall back to just printing the name of the type.
      output << reflection_of_runtime_type_name input
      --output
    )

  :fun non _inspect_hex_byte_escape_into(out String'iso, byte U8)
    out.push_byte('\\')
    out.push_byte('x')
    out = @_inspect_hex_digit_into(--out, byte.bit_shr(4))
    out = @_inspect_hex_digit_into(--out, byte.bit_and(0xF))
    --out

  :fun non _inspect_hex_digit_into(out String'iso, digit U8)
    if (digit <= 9) (
      out.push_byte(digit + '0')
    |
      out.push_byte(digit + 'A' - 0xA)
    )
    --out
